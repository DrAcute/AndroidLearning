### 把内存从Java堆复制到本地堆

OpenGL作为本体系统库直接运行在硬件上，并不通过Davik虚拟机。

```java
FloatBuffer vertextData = ByteBuffer.
      // 分配本地内存，不会被垃圾回收器管理。 例子的内存大小是浮点数组长度x每个浮点数4个字节
      .allocateDirect(tableVerticesWithTriangles.length * BYTES_PER_FLOAT)
      // 字节排序顺序
      .order(ByteOrder.nativeOrder())
      // 操作浮点数在底层字节的映射 而不是 操作单独的字节
      .asFloatBuffer();
```

1. 每个float有32bit，每个byte有8bit 所以一个float是4byte
2. 如果创建了很多ByteBuffer，需要用到堆碎片化及内存管理技术

### 管道与着色器

数据要在OpenGL的管道pipeline中传递，需要使用着色器shader。

有两种类型的shader

1. 顶点着色器 vertex shader

  生产每个顶点的最终位置，针对每个顶点，都会执行一次；
  一旦最终位置确定了，OpenGL就可以吧这些可见的顶点的集合组装成点、直线以及三角形。

  ```glsl
  attribute vec4 a_Position;
  void main()
  {
    gl_Position = a_Position;
  }
  ```
  - vec4 是包含4个分量的向量，分别为三位位置x,y,z和特殊坐标w。
  - 关键字'attribute'是把这些属性放进着色器的手段。

2. 片段着色器 fragment shader
  组成点、直线或者三角形的每个片段生成最终的颜色，针对每个片段，他都会执行一次；
  一个片段是一个小的、单一颜色的长方形区域，类似计算机屏幕上的一个像素。

  ```glsl
  precision mediump float;
  uniform vec4 u_Color;
  void main()
  {
    gl_FragColor = u_Color;
  }
  ```

  - precision mediump 是精度限定符 可以选择lowp,mediump,highp。顶点着色器默认设置为highp
  - uniform 让每个顶点使用同一个值，类似java中的static+final 
  - 颜色也是4个分量的向量 分别是red green blue alpha
  - 着色器一定要给gl_FragColor赋值，OpenGL会使用这个颜色作为当前片段的最终颜色

一旦最后颜色生成了，OpenGL就会把它们写到帧缓冲区（frame buffer）内存块中。然后，Android会把这个帧缓冲区显示到屏幕上。
